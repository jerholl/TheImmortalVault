{"version":3,"sources":["../../src/util/promisifyWorker.ts"],"sourcesContent":["import {type Worker} from 'node:worker_threads'\n\nimport {subdebug} from '../debug.js'\n\nconst debug = subdebug('worker')\n\n/**\n * Wraps a Node.js Worker in a Promise that resolves with the first message\n * the worker sends, and rejects on error, message deserialization failure,\n * or non-zero exit code. The worker is terminated after a message or error\n * is received.\n *\n * @param worker - The Worker instance to promisify\n * @returns A promise that resolves with the first message from the worker\n * @throws If the worker emits an error, a message deserialization error, or exits with a non-zero code\n * @internal\n */\nexport function promisifyWorker<T = unknown>(worker: Worker): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    let settled = false\n\n    worker.addListener('error', function onWorkerError(err) {\n      settled = true\n      debug(`Worker error: ${err.message}`, err)\n      reject(new Error(`Worker error: ${err.message}`, {cause: err}))\n      cleanup()\n    })\n    // No cleanup() here â€” the worker is already dead after exiting,\n    // so there is nothing to terminate or remove listeners from.\n    worker.addListener('exit', function onWorkerExit(code) {\n      if (code > 0) {\n        debug(`Worker exited with code ${code}`)\n        reject(new Error(`Worker exited with code ${code}`))\n      } else if (!settled) {\n        debug('Worker exited with code 0 without sending a message')\n        reject(new Error('Worker exited without sending a message'))\n      }\n    })\n    worker.addListener('messageerror', function onWorkerMessageError(err) {\n      settled = true\n      debug(`Worker message error: ${err.message}`, err)\n      reject(new Error(`Failed to deserialize worker message: ${err}`))\n      cleanup()\n    })\n    worker.addListener('message', function onWorkerMessage(message) {\n      settled = true\n      debug('Worker message %o', message)\n      resolve(message)\n      cleanup()\n    })\n\n    function cleanup() {\n      setImmediate(() => worker.terminate())\n      worker.removeAllListeners()\n    }\n  })\n}\n"],"names":["subdebug","debug","promisifyWorker","worker","Promise","resolve","reject","settled","addListener","onWorkerError","err","message","Error","cause","cleanup","onWorkerExit","code","onWorkerMessageError","onWorkerMessage","setImmediate","terminate","removeAllListeners"],"mappings":"AAEA,SAAQA,QAAQ,QAAO,cAAa;AAEpC,MAAMC,QAAQD,SAAS;AAEvB;;;;;;;;;;CAUC,GACD,OAAO,SAASE,gBAA6BC,MAAc;IACzD,OAAO,IAAIC,QAAW,CAACC,SAASC;QAC9B,IAAIC,UAAU;QAEdJ,OAAOK,WAAW,CAAC,SAAS,SAASC,cAAcC,GAAG;YACpDH,UAAU;YACVN,MAAM,CAAC,cAAc,EAAES,IAAIC,OAAO,EAAE,EAAED;YACtCJ,OAAO,IAAIM,MAAM,CAAC,cAAc,EAAEF,IAAIC,OAAO,EAAE,EAAE;gBAACE,OAAOH;YAAG;YAC5DI;QACF;QACA,gEAAgE;QAChE,6DAA6D;QAC7DX,OAAOK,WAAW,CAAC,QAAQ,SAASO,aAAaC,IAAI;YACnD,IAAIA,OAAO,GAAG;gBACZf,MAAM,CAAC,wBAAwB,EAAEe,MAAM;gBACvCV,OAAO,IAAIM,MAAM,CAAC,wBAAwB,EAAEI,MAAM;YACpD,OAAO,IAAI,CAACT,SAAS;gBACnBN,MAAM;gBACNK,OAAO,IAAIM,MAAM;YACnB;QACF;QACAT,OAAOK,WAAW,CAAC,gBAAgB,SAASS,qBAAqBP,GAAG;YAClEH,UAAU;YACVN,MAAM,CAAC,sBAAsB,EAAES,IAAIC,OAAO,EAAE,EAAED;YAC9CJ,OAAO,IAAIM,MAAM,CAAC,sCAAsC,EAAEF,KAAK;YAC/DI;QACF;QACAX,OAAOK,WAAW,CAAC,WAAW,SAASU,gBAAgBP,OAAO;YAC5DJ,UAAU;YACVN,MAAM,qBAAqBU;YAC3BN,QAAQM;YACRG;QACF;QAEA,SAASA;YACPK,aAAa,IAAMhB,OAAOiB,SAAS;YACnCjB,OAAOkB,kBAAkB;QAC3B;IACF;AACF"}