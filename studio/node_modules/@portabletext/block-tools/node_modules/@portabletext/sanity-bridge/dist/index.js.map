{"version":3,"file":"index.js","sources":["../src/portable-text-member-schema-types.ts","../src/sanity-schema-to-portable-text-schema.ts"],"sourcesContent":["import type {\n  ArraySchemaType,\n  BlockDecoratorDefinition,\n  BlockListDefinition,\n  BlockSchemaType,\n  BlockStyleDefinition,\n  ObjectSchemaType,\n  PortableTextBlock,\n  SchemaType,\n  SpanSchemaType,\n} from '@sanity/types'\n\n/**\n * @public\n * Sanity-specific schema types for Portable Text.\n */\nexport type PortableTextMemberSchemaTypes = {\n  annotations: (ObjectSchemaType & {i18nTitleKey?: string})[]\n  block: ObjectSchemaType\n  blockObjects: ObjectSchemaType[]\n  decorators: BlockDecoratorDefinition[]\n  inlineObjects: ObjectSchemaType[]\n  portableText: ArraySchemaType<PortableTextBlock>\n  span: ObjectSchemaType\n  styles: BlockStyleDefinition[]\n  lists: BlockListDefinition[]\n}\n\n/**\n * @public\n * Create Sanity-specific schema types for Portable Text from a Sanity array\n * schema type.\n */\nexport function createPortableTextMemberSchemaTypes(\n  portableTextType: ArraySchemaType<PortableTextBlock>,\n): PortableTextMemberSchemaTypes {\n  if (!portableTextType) {\n    throw new Error(\"Parameter 'portabletextType' missing (required)\")\n  }\n  const blockType = portableTextType.of?.find(findBlockType) as\n    | BlockSchemaType\n    | undefined\n  if (!blockType) {\n    throw new Error('Block type is not defined in this schema (required)')\n  }\n  const childrenField = blockType.fields?.find(\n    (field) => field.name === 'children',\n  ) as {type: ArraySchemaType} | undefined\n  if (!childrenField) {\n    throw new Error('Children field for block type found in schema (required)')\n  }\n  const ofType = childrenField.type.of\n  if (!ofType) {\n    throw new Error(\n      'Valid types for block children not found in schema (required)',\n    )\n  }\n  const spanType = ofType.find((memberType) => memberType.name === 'span') as\n    | ObjectSchemaType\n    | undefined\n  if (!spanType) {\n    throw new Error('Span type not found in schema (required)')\n  }\n  const inlineObjectTypes = (ofType.filter(\n    (memberType) => memberType.name !== 'span',\n  ) || []) as ObjectSchemaType[]\n  const blockObjectTypes = (portableTextType.of?.filter(\n    (field) => field.name !== blockType.name,\n  ) || []) as ObjectSchemaType[]\n  return {\n    styles: resolveEnabledStyles(blockType),\n    decorators: resolveEnabledDecorators(spanType),\n    lists: resolveEnabledListItems(blockType),\n    block: blockType,\n    span: spanType,\n    portableText: portableTextType,\n    inlineObjects: inlineObjectTypes,\n    blockObjects: blockObjectTypes,\n    annotations: (spanType as SpanSchemaType).annotations,\n  }\n}\n\nfunction resolveEnabledStyles(blockType: ObjectSchemaType) {\n  const styleField = blockType.fields?.find(\n    (btField) => btField.name === 'style',\n  )\n  if (!styleField) {\n    throw new Error(\n      \"A field with name 'style' is not defined in the block type (required).\",\n    )\n  }\n  const textStyles =\n    styleField.type.options?.list &&\n    styleField.type.options.list?.filter(\n      (style: {value: string}) => style.value,\n    )\n  if (!textStyles || textStyles.length === 0) {\n    throw new Error(\n      'The style fields need at least one style ' +\n        \"defined. I.e: {title: 'Normal', value: 'normal'}.\",\n    )\n  }\n  return textStyles\n}\n\nfunction resolveEnabledDecorators(spanType: ObjectSchemaType) {\n  return (spanType as any).decorators\n}\n\nfunction resolveEnabledListItems(blockType: ObjectSchemaType) {\n  const listField = blockType.fields?.find(\n    (btField) => btField.name === 'listItem',\n  )\n  if (!listField) {\n    throw new Error(\n      \"A field with name 'listItem' is not defined in the block type (required).\",\n    )\n  }\n  const listItems =\n    listField.type.options?.list &&\n    listField.type.options.list.filter((list: {value: string}) => list.value)\n  if (!listItems) {\n    throw new Error('The list field need at least to be an empty array')\n  }\n  return listItems\n}\n\nfunction findBlockType(type: SchemaType): BlockSchemaType | null {\n  if (type.type) {\n    return findBlockType(type.type)\n  }\n\n  if (type.name === 'block') {\n    return type as BlockSchemaType\n  }\n\n  return null\n}\n","import type {Schema} from '@portabletext/schema'\nimport {Schema as SanitySchema} from '@sanity/schema'\nimport {builtinTypes} from '@sanity/schema/_internal'\nimport type {\n  ArrayDefinition,\n  ArraySchemaType,\n  BlockDecoratorDefinition,\n  BlockListDefinition,\n  BlockSchemaType,\n  BlockStyleDefinition,\n  ObjectSchemaType,\n  PortableTextBlock,\n  SchemaType,\n  SpanSchemaType,\n} from '@sanity/types'\n\n/**\n * @public\n * Compile a Sanity schema to a Portable Text `Schema`.\n *\n * A Portable Text `Schema` is compatible with a Portable Text\n * `SchemaDefinition` and can be used as configuration for the Portable Text\n * Editor.\n *\n * @example\n * ```tsx\n * const schema = sanitySchemaToPortableTextSchema(sanitySchema)\n *\n * return (\n *   <EditorProvider\n *     initialConfig={{\n *       // ...\n *       schemaDefinition: schema,\n *     }}\n *   >\n *     // ...\n *   </EditorProvider>\n * ```\n */\nexport function sanitySchemaToPortableTextSchema(\n  sanitySchema: ArraySchemaType<unknown> | ArrayDefinition,\n): Schema {\n  const compiled = sanitySchema.hasOwnProperty('jsonType')\n    ? (sanitySchema as ArraySchemaType<PortableTextBlock>)\n    : compileType(sanitySchema)\n\n  return sanitySchemaTypeToSchema(compiled)\n}\n\nfunction sanitySchemaTypeToSchema(\n  portableTextType: ArraySchemaType<PortableTextBlock>,\n): Schema {\n  if (!portableTextType) {\n    throw new Error(\"Parameter 'portableTextType' missing (required)\")\n  }\n\n  const blockType = portableTextType.of?.find(findBlockType) as\n    | BlockSchemaType\n    | undefined\n  if (!blockType) {\n    throw new Error('Block type is not defined in this schema (required)')\n  }\n\n  const childrenField = blockType.fields?.find(\n    (field) => field.name === 'children',\n  ) as {type: ArraySchemaType} | undefined\n  if (!childrenField) {\n    throw new Error('Children field for block type found in schema (required)')\n  }\n\n  const ofType = childrenField.type.of\n  if (!ofType) {\n    throw new Error(\n      'Valid types for block children not found in schema (required)',\n    )\n  }\n\n  const spanType = ofType.find((memberType) => memberType.name === 'span') as\n    | ObjectSchemaType\n    | undefined\n  if (!spanType) {\n    throw new Error('Span type not found in schema (required)')\n  }\n\n  const inlineObjectTypes = (ofType.filter(\n    (memberType) => memberType.name !== 'span',\n  ) || []) as ObjectSchemaType[]\n\n  const blockObjectTypes = (portableTextType.of?.filter(\n    (field) => field.name !== blockType.name,\n  ) || []) as ObjectSchemaType[]\n\n  const styles = resolveEnabledStyles(blockType)\n  const decorators = resolveEnabledDecorators(spanType)\n  const lists = resolveEnabledListItems(blockType)\n  const annotations = (spanType as SpanSchemaType).annotations\n\n  return {\n    block: {\n      name: blockType.name,\n    },\n    span: {\n      name: spanType.name,\n    },\n    styles: styles.map((style: BlockStyleDefinition) => ({\n      name: style.value,\n      title: style.title,\n      value: style.value,\n    })),\n    lists: lists.map((list: BlockListDefinition) => ({\n      name: list.value,\n      title: list.title,\n      value: list.value,\n    })),\n    decorators: decorators.map((decorator: BlockDecoratorDefinition) => ({\n      name: decorator.value,\n      title: decorator.title,\n      value: decorator.value,\n    })),\n    annotations: annotations.map((annotation) => ({\n      name: annotation.name,\n      title: annotation.title,\n      fields: annotation.fields.map((field) => ({\n        name: field.name,\n        type: field.type.jsonType,\n        title: field.type.title,\n      })),\n    })),\n    blockObjects: blockObjectTypes.map((blockObject) => ({\n      name: blockObject.name,\n      title: blockObject.title,\n      fields: blockObject.fields.map((field) => ({\n        name: field.name,\n        type: field.type.jsonType,\n        title: field.type.title,\n      })),\n    })),\n    inlineObjects: inlineObjectTypes.map((inlineObject) => ({\n      name: inlineObject.name,\n      title: inlineObject.title,\n      fields: inlineObject.fields.map((field) => ({\n        name: field.name,\n        type: field.type.jsonType,\n        title: field.type.title,\n      })),\n    })),\n  }\n}\n\nfunction resolveEnabledStyles(blockType: ObjectSchemaType) {\n  const styleField = blockType.fields?.find(\n    (btField) => btField.name === 'style',\n  )\n  if (!styleField) {\n    throw new Error(\n      \"A field with name 'style' is not defined in the block type (required).\",\n    )\n  }\n  const textStyles =\n    styleField.type.options?.list &&\n    styleField.type.options.list?.filter(\n      (style: {value: string}) => style.value,\n    )\n  if (!textStyles || textStyles.length === 0) {\n    throw new Error(\n      'The style fields need at least one style ' +\n        \"defined. I.e: {title: 'Normal', value: 'normal'}.\",\n    )\n  }\n  return textStyles\n}\n\nfunction resolveEnabledDecorators(spanType: ObjectSchemaType) {\n  return (spanType as any).decorators\n}\n\nfunction resolveEnabledListItems(blockType: ObjectSchemaType) {\n  const listField = blockType.fields?.find(\n    (btField) => btField.name === 'listItem',\n  )\n  if (!listField) {\n    throw new Error(\n      \"A field with name 'listItem' is not defined in the block type (required).\",\n    )\n  }\n  const listItems =\n    listField.type.options?.list &&\n    listField.type.options.list.filter((list: {value: string}) => list.value)\n  if (!listItems) {\n    throw new Error('The list field need at least to be an empty array')\n  }\n  return listItems\n}\n\nfunction findBlockType(type: SchemaType): BlockSchemaType | null {\n  if (type.type) {\n    return findBlockType(type.type)\n  }\n\n  if (type.name === 'block') {\n    return type as BlockSchemaType\n  }\n\n  return null\n}\n\nfunction compileType(rawType: any) {\n  return SanitySchema.compile({\n    name: 'blockTypeSchema',\n    types: [rawType, ...builtinTypes],\n  }).get(rawType.name)\n}\n"],"names":["findBlockType","resolveEnabledStyles","resolveEnabledDecorators","resolveEnabledListItems","SanitySchema"],"mappings":"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"}